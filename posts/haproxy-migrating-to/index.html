<!doctype html><html lang=en><head><title>HAProxy Migration Challenges: Navigating the Transition from Ingress-NGINX to HAProxy Ingress Controller · Dusty Dev</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="DevDust80"><meta name=description content="The ingress-nginx controller is approaching end-of-life1, leaving us with limited time to find a suitable replacement. We need a solution that preserves our existing feature set whilst managing the inevitable changes to configuration and architectural concepts. Several options exist in this space, but as part of this practice I wanted to share my experience with migrating from ingress-nginx to HAProxy Ingress Controller, and the challenges I faced during this process. One of the main challenges was related to mTLS and client certificate authentication, specifically in the scenario where we wanted to allow for mTLS without enforcing strict SSL verification, and also passing the client certificate to the backend services which is a common use case in many applications but is not natively supported in official HAProxy Ingress Controller2."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="HAProxy Migration Challenges: Navigating the Transition from Ingress-NGINX to HAProxy Ingress Controller"><meta name=twitter:description content="The ingress-nginx controller is approaching end-of-life1, leaving us with limited time to find a suitable replacement. We need a solution that preserves our existing feature set whilst managing the inevitable changes to configuration and architectural concepts. Several options exist in this space, but as part of this practice I wanted to share my experience with migrating from ingress-nginx to HAProxy Ingress Controller, and the challenges I faced during this process. One of the main challenges was related to mTLS and client certificate authentication, specifically in the scenario where we wanted to allow for mTLS without enforcing strict SSL verification, and also passing the client certificate to the backend services which is a common use case in many applications but is not natively supported in official HAProxy Ingress Controller2."><meta property="og:url" content="https://devdust80.github.io/blog/posts/haproxy-migrating-to/"><meta property="og:site_name" content="Dusty Dev"><meta property="og:title" content="HAProxy Migration Challenges: Navigating the Transition from Ingress-NGINX to HAProxy Ingress Controller"><meta property="og:description" content="The ingress-nginx controller is approaching end-of-life1, leaving us with limited time to find a suitable replacement. We need a solution that preserves our existing feature set whilst managing the inevitable changes to configuration and architectural concepts. Several options exist in this space, but as part of this practice I wanted to share my experience with migrating from ingress-nginx to HAProxy Ingress Controller, and the challenges I faced during this process. One of the main challenges was related to mTLS and client certificate authentication, specifically in the scenario where we wanted to allow for mTLS without enforcing strict SSL verification, and also passing the client certificate to the backend services which is a common use case in many applications but is not natively supported in official HAProxy Ingress Controller2."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-07T13:51:00+00:00"><meta property="article:modified_time" content="2026-02-07T13:51:00+00:00"><meta property="article:tag" content="Cloud"><meta property="article:tag" content="Migration"><meta property="article:tag" content="Ingress"><meta property="article:tag" content="OSS"><meta property="article:tag" content="Kubernetes"><link rel=canonical href=https://devdust80.github.io/blog/posts/haproxy-migrating-to/><link rel=preload href=https://devdust80.github.io/blog/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://devdust80.github.io/blog/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=https://devdust80.github.io/blog/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=https://devdust80.github.io/blog/css/coder.min.4b392a85107b91dbdabc528edf014a6ab1a30cd44cafcd5325c8efe796794fca.css integrity="sha256-SzkqhRB7kdvavFKO3wFKarGjDNRMr81TJcjv55Z5T8o=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://devdust80.github.io/blog/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=https://devdust80.github.io/blog/css/custom.min.964de8f19e2f91f2211746344534d7f3f65ca4918c1bde7ffa2398d90d98a01f.css integrity="sha256-lk3o8Z4vkfIhF0Y0RTTX8/ZcpJGMG95/+iOY2Q2YoB8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=https://devdust80.github.io/blog/images/favicon.svg sizes=any><link rel=icon type=image/png href=https://devdust80.github.io/blog/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=https://devdust80.github.io/blog/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=https://devdust80.github.io/blog/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=https://devdust80.github.io/blog/images/apple-touch-icon.png><link rel=manifest href=https://devdust80.github.io/blog/site.webmanifest><link rel=mask-icon href=https://devdust80.github.io/blog/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://devdust80.github.io/blog/>Dusty Dev
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=https://devdust80.github.io/blog/posts/>Ramblings</a></li><li class=navigation-item><a class=navigation-link href=https://devdust80.github.io/blog/experiences/>Experiences</a></li><li class=navigation-item><a class=navigation-link href=https://devdust80.github.io/blog/about/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://devdust80.github.io/blog/posts/haproxy-migrating-to/>HAProxy Migration Challenges: Navigating the Transition from Ingress-NGINX to HAProxy Ingress Controller</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2026-02-07T13:51:00Z>February 7, 2026
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
6-minute read</span></div><div class=authors><i class="fa-solid fa-user" aria-hidden=true></i>
<a href=https://devdust80.github.io/blog/authors/devdust80/>Devdust80</a></div><div class=categories><i class="fa-solid fa-folder" aria-hidden=true></i>
<a href=https://devdust80.github.io/blog/categories/cloud/>Cloud</a>
<span class=separator>•</span>
<a href=https://devdust80.github.io/blog/categories/migration/>Migration</a>
<span class=separator>•</span>
<a href=https://devdust80.github.io/blog/categories/ingress/>Ingress</a>
<span class=separator>•</span>
<a href=https://devdust80.github.io/blog/categories/oss/>OSS</a>
<span class=separator>•</span>
<a href=https://devdust80.github.io/blog/categories/kubernetes/>Kubernetes</a></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=https://devdust80.github.io/blog/tags/cloud/>Cloud</a>
</span><span class=separator>•</span>
<span class=tag><a href=https://devdust80.github.io/blog/tags/migration/>Migration</a>
</span><span class=separator>•</span>
<span class=tag><a href=https://devdust80.github.io/blog/tags/ingress/>Ingress</a>
</span><span class=separator>•</span>
<span class=tag><a href=https://devdust80.github.io/blog/tags/oss/>OSS</a>
</span><span class=separator>•</span>
<span class=tag><a href=https://devdust80.github.io/blog/tags/kubernetes/>Kubernetes</a></span></div></div></header><div class=post-content><p>The ingress-nginx controller is approaching end-of-life<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, leaving us with limited time to find a suitable replacement. We need a solution that preserves our existing feature set whilst managing the inevitable changes to configuration and architectural concepts. Several options exist in this space, but as part of this practice I wanted to share my experience with migrating from ingress-nginx to HAProxy Ingress Controller, and the challenges I faced during this process. One of the main challenges was related to mTLS and client certificate authentication, specifically in the scenario where we wanted to allow for mTLS without enforcing strict SSL verification, and also passing the client certificate to the backend services which is a common use case in many applications but is not natively supported in official HAProxy Ingress Controller<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>.</p><p>Official HAProxy<sup id=fnref1:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> is a powerful load balancer and reverse proxy controller that enables Kubernetes workloads to be exposed and accessible to external clients. It is natively allows for enabling mTLS but it lacks the option to allow failures if the verification didn&rsquo;t succeeded due to the CA was not present in the local store, or as pointed earlier the verification option of <code>optional_no_ca</code> does not exist here. This means that if we want to enable mTLS with HAProxy, we need to ensure that all client certificates are properly verified against a trusted CA and the certs must be valid and the chain must be present in the local store, otherwise the connection will be rejected. This can be a significant challenge for applications that rely on client certificate authentication but do not have a strict requirement for SSL verification, as it may lead to disruptions in service if the client certificates are not properly managed or if there are issues with the CA trust chain.</p><h2 id=the-background-how-ingress-nginx-handles-mtls-and-client-certificate-authentication>The background: how ingress-nginx handles mTLS and client certificate authentication
<a class=heading-link href=#the-background-how-ingress-nginx-handles-mtls-and-client-certificate-authentication><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>As ingress-nginx was widely adopted and used across the industry, so many things have been added to it and by default there are so many annotations that we can add that allows to support multiple configs per each entry, amongst them are:</p><ul><li><code>nginx.ingress.kubernetes.io/auth-tls-secret</code></li><li><code>nginx.ingress.kubernetes.io/auth-tls-pass-certificate-to-upstream</code></li><li>But the most important one <code>nginx.ingress.kubernetes.io/auth-tls-verify-client: optional_no_ca</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></li></ul><p>with value of <mark>optional_no_ca</mark>. Some part of it HAProxy can do natively out-of-the-box, like enabling mTLS but regarding the verification it is very strict. Ingress-nginx allows configuration per ingress resource with customised annotations present then the controller will generate appropriate nginx configuration for that specific ingress resource, this allows for a lot of flexibility and granularity in terms of how we can configure mTLS and client certificate authentication on a per-service basis. HAProxy, on the other hand, does not have the same level of granularity and flexibility when it comes to mTLS configuration, and it may require additional workarounds or custom configurations to achieve similar functionality.</p><h2 id=haproxy-mtls-and-client-certificate-authentication-challenges>HAProxy mTLS and client certificate authentication challenges
<a class=heading-link href=#haproxy-mtls-and-client-certificate-authentication-challenges><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>HAProxy helm chart supports enabling mTLS but it lacks the option to allow failures if the verification didn&rsquo;t succeeded due to the CA was not present in the local store, or in situations where there is no need to enforce strict verification by sending the client the list of trusted CAs, If that is set then the client would check the list of CAs being presented by the controller and check them against its own CAs and if that was not present then it would not send back anything which is a problematic in this situation as we want to suppress the error and still allow the connection to proceed. But before progressing into how this can be achieved, lets first understand how HAProxy generated needed configuration for mTLS.</p><h3 id=that-would-be-bind-directive>That would be <code>bind</code> directive
<a class=heading-link href=#that-would-be-bind-directive><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>In HAProxy, the magic happens at the <code>bind</code> directive. When using official helm chart<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, some of the flags would be set by default through helm values, they are usually get populated based on the supported annotations<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> that are supported by HAProxy ingress controller. Firstly to enable mTLS feature we can set:</p><ul><li><code>client-ca</code></li><li><code>client-crt-optional</code></li></ul><p>This is the minimum configuration needed to allow for mTLS for both clients that present a valid certificate and those that do not. The <strong>gotcha</strong> here is that if they do present a certificate, it should be a valid one and they should be signed by the same CA that is specified in the former flag. So the values for these flags would be as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># values.yaml</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nt>controller</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>config</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>client-ca</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;namespace/secret-name&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>client-crt-optional</span><span class=p>:</span><span class=w> </span><span class=s2>&#34;true&#34;</span><span class=w>
</span></span></span></code></pre></div><p>When setting these flags, HAProxy will generate appropriate configuration for the <code>bind</code> directive in the config file, which will look something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># /etc/haproxy/haproxy.cfg</span>
</span></span><span class=line><span class=cl><span class=nb>bind</span> :443 ssl crt ... ca-file /etc/haproxy/certs/ca/ca.crt verify optional
</span></span></code></pre></div><h2 id=what-about-passing-the-client-certificate-to-the-backend-services>What about passing the client certificate to the backend services?
<a class=heading-link href=#what-about-passing-the-client-certificate-to-the-backend-services><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Now that we have enabled mTLS and allowed for clients that do not present a valid certificate, we now need to consider how to also allow for the clients that does not present a valid certificate so still HAProxy would terminate the TLS connection and pass the client certificate to the backend service. Looking at supported annotations<sup id=fnref1:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> we can see that there is no default annotations that allows us for such scenario, but HAProxy itself does support this feature but it requires adding custom configuration through the use of official HAProxy ingress controller helm chart<sup id=fnref1:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>. HAProxy engine deals with this scenario through the same <code>bind</code> directive and we need to add two more flags to the directive so that it would allow for invalid certificates and also to pass them to the backend services, these flags are:</p><ul><li><code>no-ca-names</code></li><li><code>crt-ignore-err</code></li></ul><p><mark>no-ca-names</mark> will prevent HAProxy from sending the list of trusted CAs to the client, which will allow clients that do not have a valid certificate to still connect to the controller. <mark>crt-ignore-err</mark> will allow HAProxy to ignore any errors related to invalid certificates and still pass them to the backend services. With these flags added, the <code>bind</code> directive would look something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>bind</span> :443 ssl crt ... ca-file /etc/haproxy/certs/ca/ca.crt verify optional no-ca-names crt-ignore-err 20,21
</span></span></code></pre></div><h3 id=what-are-the-numbers-20-and-21-in-the-crt-ignore-err-flag>What are the numbers 20 and 21 in the <code>crt-ignore-err</code> flag?
<a class=heading-link href=#what-are-the-numbers-20-and-21-in-the-crt-ignore-err-flag><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>With having the <code>crt-ignore-err</code> flag set to 20,21, HAProxy will ignore errors related to invalid certificates and still pass them to the backend services. The numbers 20 and 21 correspond<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> to specific error codes that HAProxy will ignore when processing client certificates. Error code 20 corresponds to &ldquo;certificate expired&rdquo; and error code 21 corresponds to &ldquo;certificate not yet valid&rdquo;. By ignoring these errors, HAProxy will allow clients with expired or not yet valid certificates to still connect to the controller and have their certificates passed to the backend services for further processing. This can be useful in scenarios where you want to allow for mTLS but do not want to enforce strict certificate validation, such as in development or testing environments.</p><h2 id=chart>Chart
<a class=heading-link href=#chart><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>The overview of how the packets flow in this scenario would be as follows:</p><div class=mermaid>sequenceDiagram
participant Client
participant HAProxy
participant Backend
Client->>HAProxy: Send Request with or without client certificate
HAProxy->>HAProxy: verification
HAProxy->>HAProxy: Verification result (pass/fail)
HAProxy->>Backend: Pass packet to backend (if verified)
Backend->>Client: Response</div><hr><h4 id=footnotes>Footnotes
<a class=heading-link href=#footnotes><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Ingress NGINX Retirement: <a href=https://kubernetes.io/blog/2025/11/11/ingress-nginx-retirement/ class=external-link target=_blank rel=noopener>What You Need to Know</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://haproxy-ingress.github.io/ class=external-link target=_blank rel=noopener>Official HAProxy</a>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Client certificate authentication <a href=https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#client-certificate-authentication class=external-link target=_blank rel=noopener>nginx-config</a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://github.com/haproxytech/helm-charts/tree/main/kubernetes-ingress class=external-link target=_blank rel=noopener>HAProxy ingress-controller Helm Chart</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://github.com/haproxytech/kubernetes-ingress/blob/master/documentation/annotations.md class=external-link target=_blank rel=noopener>HAProxy ingress-controller annotations</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://github.com/openssl/openssl/blob/master/include/openssl/x509_vfy.h.in class=external-link target=_blank rel=noopener>SSL error codes</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2026
DevDust80
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=https://cdn.jsdelivr.net/npm/mermaid@9.3.0/dist/mermaid.min.js integrity="sha256-QdTG1YTLLTwD3b95jLqFxpQX9uYuJMNAtVZgwKX4oYU=" crossorigin=anonymous></script><script>mermaid.initialize({startOnLoad:!0})</script><script src=https://devdust80.github.io/blog/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>